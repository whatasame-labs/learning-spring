# Generated identifier

JPA gives some sort of ways of generated identifier strategy: `AUTO`, `IDENTITY`, `SEQUENCE`, `TABLE`. Hibernate
implements all of them.

## AUTO

`AUTO` is the default strategy. It lets the persistence provider (Hibernate) choose the appropriate strategy based on
the database provider.

If id type is `UUID`, Hibernate will use `UUIDGenerator` to generate id.

If id type is Numeric, Hibernate will use `SequenceStyleGenerator` to generate id.

## SEQUENCE

`SEQUENCE` strategy is used to generate a sequence-based identifier. Hibernate will use `SequenceStyleGenerator` to be
capable of working against databases that do not support sequences.

Although provider (e.g. MySQL) does not support sequences, Hibernate support `SEQUENCE` strategy by using a table. It
gives a huge degree of portability across databases while still maintaining consistent id generation behavior (versus
say choosing between SEQUENCE and IDENTITY).

In default, Hibernate use sequence name using table name with suffix `_seq`. You can also specify
using `@GeneratedValue#generator`:

```java
@Entity
public class User{

    @Id
    @GeneratedValue(generator = "super_duper_seq")
    private Long id;
}
```

## IDENTITY

`IDENTITY` strategy is used to generate a database identity column. Hibernate will use `IdentityGenerator` which expect
the identifier to be generated by INSERT into the table. There is three ways for retreiving the INSERT-generated value.

* If JDBC supports `java.sql.Statement#getGeneratedKeys`, Hibernate will use for extracting the generated key.
* Otherwise, if `Dialect#supportInsertSelectIdentity` reports true, Hibernate will use INSERT+SELECT statement.
* Otherwise, Hibernate will expect the database to support command asking for the most recently inserted IDENTITY value
  via `Dialect#getIdentitySelectString`.

### Hibernate will not be able to batch INSERT statements for the entities using the IDENTITY generation

The reason why it is happens is that Hibernate tries to defer the Persistence Context flushing up until the last
possible moment known
as transactional write-behind. The flushed changes are visible only for the current database transaction. Until the
current transaction is committed, no change is visible by other concurrent transactions.

The only drawback is that we canâ€™t know the newly assigned value prior to executing the INSERT statement. This
restriction is hindering the transactional write-behind flushing strategy adopted by Hibernate. For this reason,
Hibernates disables the JDBC batch support for entities using the IDENTITY generator.

If you need batching for insert, **you can use JDBC for that.**

## TABLE

`TABLE` strategy is used to generate an identifier by using a database table as a source of unique identifier values. It
is configurable by `@TableGenerator` and `@GeneratedValue#generator`

## References

* [3.7.7. Generated identifier values - Hibernate User Guide](https://docs.jboss.org/hibernate/orm/6.4/userguide/html_single/Hibernate_User_Guide.html#identifiers-generators)
* [Why does Hibernate disable INSERT batching when using an IDENTITY identifier generator - Stackoverflow](https://stackoverflow.com/a/27732138)
